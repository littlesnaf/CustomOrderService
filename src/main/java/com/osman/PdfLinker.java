package com.osman;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Helper utilities that link Amazon shipping label PDFs to order identifiers by parsing
 * the summary page generated by Amazon Seller Central.
 */
public class PdfLinker {
    private static final Pattern ORDER_ID_PATTERN = Pattern.compile("\\b\\d{3}-\\d{7}-\\d{7}\\b");
    private static final Pattern PACKING_SLIP_PATTERN =
            Pattern.compile("(?i)(?:^(?:\\d{2}[PRWB]|mix)(\\s*\\(\\d+\\))?\\.pdf$)|(?:^amazon.*\\.pdf$)");
    private static final Pattern PACKING_SLIP_FOLDER_PATTERN =
            Pattern.compile("^(?:\\d{2}\\s*[PRWB]|mix).*", Pattern.CASE_INSENSITIVE);

    /** Determines if the given PDF name matches known packing-slip naming conventions. */
    private static boolean isPackingSlipFile(File pdfFile) {
        if (pdfFile == null) return false;
        String name = pdfFile.getName();
        if (PACKING_SLIP_PATTERN.matcher(name).matches()) return true;
        String lower = name.toLowerCase();
        if (lower.startsWith("amazon")) {
            File parent = pdfFile.getParentFile();
            if (parent != null && PACKING_SLIP_FOLDER_PATTERN.matcher(parent.getName()).matches()) {
                return true;
            }
            return true;
        }
        return false;
    }

    /** Loads a PDF from disk and returns an index of order IDs to label pages, skipping slips. */
    public static Map<String, List<Integer>> buildOrderIdToPagesMap(File labelsPdf) throws IOException {
        if (labelsPdf == null || !labelsPdf.isFile()) {
            throw new IOException("Labels PDF not found: " + labelsPdf);
        }
        if (isPackingSlipFile(labelsPdf)) {
            return new LinkedHashMap<>();
        }
        try (PDDocument doc = PDDocument.load(labelsPdf)) {
            return buildOrderIdToPagesMap(doc);
        }
    }

    /**
     * Scans an open PDF document for the "List of orders" summary, which may span
     * multiple pages at the end of the document, and maps each order ID to its label page.
     */
    public static Map<String, List<Integer>> buildOrderIdToPagesMap(PDDocument doc) throws IOException {
        Map<String, List<Integer>> map = new LinkedHashMap<>();
        int pageCount = doc.getNumberOfPages();
        if (pageCount < 2) {
            return map; // Not enough pages for a label and an index
        }

        // Step 1: Find the starting page of the order list by searching backward from the end.
        int indexStartPage = -1;
        PDFTextStripper stripper = new PDFTextStripper();
        stripper.setSortByPosition(true);

        for (int p = pageCount; p >= 1; p--) {
            String pageText = extractPageText(stripper, doc, p);
            // Use a broader search key to match "List of orders..."
            if (pageText != null && pageText.toLowerCase().contains("list of orders")) {
                indexStartPage = p;
                break; // Found the first page of the index, stop searching
            }
        }

        if (indexStartPage == -1) {
            return map; // Index page with the key phrase was not found.
        }

        // Step 2: Read all text from all index pages (from the start page to the end) into one string.
        StringBuilder fullIndexText = new StringBuilder();
        for (int p = indexStartPage; p <= pageCount; p++) {
            String pageText = extractPageText(stripper, doc, p);
            if (pageText != null) {
                fullIndexText.append(pageText).append(System.lineSeparator());
            }
        }

        // Step 3: Extract all order IDs from the combined index text.
        List<String> orderIds = new ArrayList<>();
        Matcher m = ORDER_ID_PATTERN.matcher(fullIndexText.toString());
        while (m.find()) {
            orderIds.add(m.group());
        }

        // Step 4: Map the found order IDs to the actual label pages.
        if (!orderIds.isEmpty()) {
            int labelPageCount = indexStartPage - 1;
            int ordersToMapCount = Math.min(orderIds.size(), labelPageCount);

            for (int i = 0; i < ordersToMapCount; i++) {
                String orderId = orderIds.get(i);
                int pageNum = i + 1; // Label pages are 1, 2, 3...
                map.computeIfAbsent(orderId, k -> new ArrayList<>()).add(pageNum);
            }
        }

        return map;
    }

    /**
     * Extracts text from a specific one-based page index using a shared PDFTextStripper instance.
     */
    private static String extractPageText(PDFTextStripper stripper, PDDocument doc, int pageIndex1Based) throws IOException {
        stripper.setStartPage(pageIndex1Based);
        stripper.setEndPage(pageIndex1Based);
        return stripper.getText(doc);
    }
}
